;; 29 juin 2023
;; Auteurs: Cintia Dalila Soares - C2791
;;          Carl Thibault - 0985781

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; FORMES SPÉCIALES - Expressions "fun"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dec f0 (Int -> Int))                           
(def f0 (fun x (+ x 1)))                                        ; <Fonction> : Tarw (Tprim "Int") (Tprim "Int")

(def f1 (: (fun x (+ x 1)) (Int -> Int)))                       ; <Fonction> : Tarw (Tprim "Int") (Tprim "Int")

(dec f2 (Int Int -> Int))
(def f2 (fun x (fun y (+ x y))))                                ; <Fonction> : Tarw (Tprim "Int") (Tarw (Tprim "Int") (Tprim "Int"))

(def f3 (: (fun x (fun y (+ x y))) (Int Int -> Int)))           ; <Fonction> : Tarw (Tprim "Int") (Tarw (Tprim "Int") (Tprim "Int"))

(def testF4 fun)                                                ; <FormeSpéciale-fun> : Tprim "SpecialForm"
(def f4 (: (testF4 x (testF4 y (+ x y))) (Int Int -> Int)))     ; <Fonction> : Tarw (Tprim "Int") (Tarw (Tprim "Int") (Tprim "Int"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; FORMES SPÉCIALES - Expressions "if"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dec testIf1 Int)
(def testIf1 (if true 1 0))             ; 1 : Tprim "Int"

(dec testIf2 Int)
(def testIf2 (if false 1 0))            ; 0 : Tprim "Int"

(dec testIf3 Int)                       
(def testIf3 (if (zero? 1) 0 1))        ; 1 : Tprim "Int"

(def testIf4 if)                        
(dec if4 Int)
(def if4 (testIf4 (zero? 1) 0 1234))    ; 1234 : Tprim "Int"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; FORMES SPÉCIALES - Expressions "Let"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def testLet1 (let ((x 1)) (+ x x)))                                    ; 2 : Tprim "Int"
(def testLet2 (let ((x 1) (y 2)) (+ x y)))                              ; 3 : Tprim "Int"
(def testLet3 (let ((x 1) (y 2) (z 3)) (+ (+ x y) z)))                  ; 6 : Tprim "Int"
(def testLet5 (let ((x 1)) (f0 x)))                                     ; 2 : Tprim "Int"
(def testLet6 (let ((x 1) (y 2)) (f4 x y)))                             ; 3 : Tprim "Int"
(def testLet7 (let ((x 1) (w (let ((y 2) (z 3)) (+ y z)))) (f4 x w)))   ; 6 : Tprim "Int"
(def testLet8 (let ((x 1) (y 2)) (let ((z 10)) (+ (+ x y) z))))         ; 13 : Tprim "Int"
(def testLet4 (let ((x 1) (y (+ x 2)) (z (+ y 2))) (+ (+ x y) z)))      ; 7 : Tprim "Int"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TESTS MACROS - Arguments et moremacro
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; MacroId avec différentes sortes d'expressions
(def testMacroId (macro (fun s s)))
(def idTrue (testMacroId (zero? 0)))                    ;   1 : Tprim "Bool"
(def deux   (testMacroId (+ 1 1)))                      ;   2 : Tprim "Int"
(def trois  (testMacroId (let ((x 4) (y -1)) (+ x y)))) ;   3 : Tprim "Int"
(def quatre (f1 3))                                     ;   4 : Tprim "Int"

;; Macro renvoyant le 1er argument
(def testMacroIdFstArg
    (macro
        (fun x
            (moremacro
                (fun y (car (cons x y)))))))
(def testFst1 (testMacroIdFstArg 1 2))                  ;   1 : Tprim "Int"

;; Macro renvoyant le 2e argument
(def testMacroIdSndArg
    (macro
        (fun x
            (moremacro
                (fun y (cdr (cons x y)))))))
(def testSnd1 (testMacroIdSndArg 1 2))                  ;   2 : Tprim "Int"

;; Macro fonction à 1 argument avec moremacro
(def oneArgFun
     (macro (fun arg (moremacro
                      (fun body (cons (cons 'fun arg) body))))))
(def testFunInc (: (oneArgFun x (+ x 1)) (Int -> Int)))
(def testInc (testFunInc 99))

;; Macro fonction à 2 arguments avec moremacro (ERREUR)
;; (def twoArgsFun
;;      (macro (fun argOne 
;;         (moremacro (fun argTwo 
;;             (moremacro (fun body 
;;                         (cons (cons (cons 'fun argOne) argTwo) body))))))))
;; (def testFunAdd (: (twoArgsFun x y (+ x y)) (Int Int -> Int)))
;; (def testAdd (testFunAdd 100 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TESTS MACROS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Macro auxiliaires importées de "exemples 2" ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def multi-macro
     (macro (fun args
                 (moremacro
                  (fun body
                       (let ((head (car args)))
                         (let ((tail (cdr args)))
                           (let ((tailfun (cons (cons 'fun tail) body)))
                             (if (nil? head)
                                 (cons 'macro tailfun)
                               (cons (cons 'multi-macro head)
                                     (cons 'moremacro tailfun)))))))))))

(def defmacro (multi-macro (name args body)
                           (cons (cons 'def name)
                                 (cons (cons 'multi-macro args) body))))

(defmacro lambda (args body)
  (let ((head (car args))) ; liste sans le dernier arguments
    (let ((tail (cdr args))) ; dernier element
        (let ((body-next (cons (cons 'fun tail ) body))) ; fonction appliqué au dernier element
            (if (nil? head) ; regarde s'il n'y a plus d'argument à passer
              body-next ; retourne juste la fonction applique au dernier argument
              (cons(cons 'lambda head) body-next) ; sinon, retourne lambda-aux avec la liste sans le dernier argument
            ))))
            ) ; avec tailfun après

(dec not (Bool -> Bool))
(def not (lambda (x) (if x false true)))

(defmacro and (e1 e2)
   (cons (cons ': (cons (cons (cons 'if e1) e2) 'false)) 'Bool))

 (defmacro shorthand-backquote (e)
   (if (not (cons? e))
       (cons (cons nil 'shorthand-quote) e)
     (let ((head (car e))
           (tail (cdr e)))
       (if (and (and (cons? head) (nil? (car head)))
                (and (sym? (cdr head))
                     (str-eq? (sym-name (cdr head))
                              (sym-name 'shorthand-comma))))
           tail
         (cons (cons 'cons (cons 'shorthand-backquote head))
               (cons 'shorthand-backquote tail))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
;; Macro pour fonctions à 2 arguments avec multimacro

(def myfun3 (multi-macro (arg1 arg2 body) 
    (cons (cons 'fun arg1) (cons (cons 'fun arg2) body))))

(def r11 (: (myfun3 x y (+ x y)) (Int Int -> Int)))
(def r12 (r11 11 1))

(defmacro twoArgsFun (argOne argTwo body)
    (cons (cons 'fun argOne) (cons (cons 'fun argTwo) body)))

(def r13 (: (twoArgsFun x y (- x y)) (Int Int -> Int)))
(def r14 (r13 15 1))

;; Un "if" qui prend 2 conditions en arguments et retourne ev si 
;; les 2 conditions sont vraies sinon renvoie ef
;;(defmacro macroIfAnd2Cnd (ec1 ec2 ev ef)
;;  `(: (if (and ,ec1 ,ec2) ,ev ,ef) Bool))
;;(def macroIfAnd2 (macroIfAnd2Cnd (zero? 1) (zero? 0) (+ 1 0) (- 1 1)))

;; Macro if qui prend l'opposé de la condition et redonne le résultat approprié
;;(defmacro macroOppositeIf (ec ev ef)
;;  `(: (if (not ,ec) ,ev ,ef) Bool))
;;(def macroOppositeIf (macroIfAnd2Cnd (zero? 1) (+ 1 0) (- 1 1)))

;; Macro de la fonction factorielle adaptée de 
;; l'exercice 8.11 du livre "The Common Lisp Companion" par Timothy Koschmann
;;(defmacro testMacroFactorial (num)
;;    (let ((n num)))
;;        (if (zero? n)
;;        1
;;        '(* ,n (testMacroFactorial ,(- n 1)))))
;;(def testMacroFactorial 5)